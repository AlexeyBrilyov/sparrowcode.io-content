Смотрите: если вы вызываете инициализатор у`UIView`, система сразу выделит память. У контроллера тоже имеется вью, но есть нюанс.

> То, что контроллер создан, не означает, что вью создана тоже. 

Система ждёт причину создать вью, и сейчас мы разберём, как это работает. Концепция жизненного цикла строится вокруг этой особенности. Просто держите в уме, что вью создаётся по необходимости. Погнали!

## Инициализируем

Рассмотрим базовый `UIViewController`, инициализаторов два:

```swift
override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
    super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
}
    
required init?(coder: NSCoder) {
    super.init(coder: coder)
}
```

Ещё есть инициализатор без параметров `init()`, но это обёртка над первым инициализатором.

На этом этапе контроллер инициализирует проперти и отрабатывает тело инициализатора. Вью не загружается, аутлеты не активны. В инициализаторе с nib сохраняется только имя файла, сам файл не подгружается. Про загрузку вью дальше расскажем.

## Загружаем View

Разработчик презентует контроллер. Для системы это повод выделить память и загрузить вью, а мы можем следить за процессом и даже вмешиваться. Глянем, какие методы доступны.

```swift
override func loadView() {}
```

Метод `loadView()` вызывается системой. Его не нужно вызывать вручную, но можно переопределить, чтобы подменить корневую вью. Если нужно загрузить вью вручную (и вы знаете, что делаете), то держите красную кнопку `loadViewIfNeeded()`. Узнать, загружена ли вью, можно через проперти контроллера `isViewLoaded`.

Второй метод легендарен, как Стив Джобс. Он вызывается, когда вью закончила загрузку.

```swift
override viewDidLoad() {
    super.viewDidLoad()
}
```

Разработчики не просто так настраивают контроллер и вьюхи в методе `viewDidLoad()`. До вызова этого метода корневой вью ещё не существует, а после контроллер уже готов появиться на экране. `viewDidLoad()` — отличное место. Память под вью выделена, вью загружена и готова к настройке.

> Вью нельзя настраивать в инициализаторе. При обращении к `controller.view` она загрузится, но контроллер появится на экране не сейчас. Или вообще не появится. 

Проект от такого не крашнется, но элементы интерфейса расходуют память — нет смысла тратить её раньше, чем нужно. Делайте это по необходимости.

Раньше я делал проперти-вьюхи контроллера, просто создавая их:

```swift
class ViewController: UIViewController {
    
    let redView = UIView()
}
```

Проперти инициализируется вместе с контроллером, а значит, память для вью выделится сразу. Если хотите отложить это до требования, пометьте проперти как `lazy`.

В методе `viewDidLoad()` размеры вьюхи неверные, привязываться к высоте и ширине нельзя. Делайте настройку, которая не зависит от размеров.

Теперь хочу остановиться на `viewDidUnload()`. Корневая вью может выгружаться из памяти, а это означает кое-что невероятное!

>Метод `viewDidLoad()` может вызываться несколько раз.

Если модальный контроллер закрыть, вью выгрузится из памяти, но объект контроллера будет жив. Аутлеты здесь активны, но уже не имеют смысла — их можно ресетить. Если показать контроллер ещё раз, вью снова загрузится. Если система выгрузила вью, значит, у неё была причина. Не нужно обращаться к корневой вью в этом методе — это загрузит вью.

Также не берите внеурочные, чтобы все выходные переделывать вашу VPN-ку. Ничего не сломается, `viewDidLoad()` редко вызывается несколько раз. Держите в уме, что нужно разнести настройку данных и вьюх в следующем проекте.

## Показываем и прячем View

Появление контроллера начинается с метода `viewWillAppear`:

```swift
override func viewWillAppear(_ animated: Bool) {
    super.viewWillAppear(animated)
}
    
override func viewDidAppear(_ animated: Bool) {
    super.viewDidAppear(animated)
}
```

Появление контроллера в модальном окне или переход в `UINavigationController`-e вызовут `viewWillAppear` до анимации, а `viewDidAppear` — после. При вызове `viewWillAppear` вью уже находится в иерархии.

Оба метода в связке. Тут делать настройку не нужно, но можно спрятать или показать вьюхи, а может, добавить несложное поведение. В методе `viewDidAppear()` начинайте сетевой запрос или крутите индикатор загрузки. Оба метода могут вызываться несколько раз.

Есть методы, которые сообщают, что вью пропадает с экрана. Вот наглядная схема:

![Схема жизненного цикла `ViewController`.](https://cdn.sparrowcode.io/tutorials/uiviewcontroller-lifecycle/header.jpg)

Обратите внимание на пару антагонистов `viewWillDisappear()` и `viewDidDisappear()`. Они вызываются, когда вью удаляется из иерархии представлений. Если вы показываете другой контроллер поверх, то методы не вызываются.

## Layout

Методы лейаута, аналогично методам выше, подвязаны к жизненному циклу вьюхи. Доступно 3 метода:

```swift
override func viewWillLayoutSubviews() {
    super.viewWillLayoutSubviews()
}
    
override func viewDidLayoutSubviews() {
    super.viewDidLayoutSubviews()
}
```

Первый метод вызывается до `layoutSubviews()` корневой вью, второй после. Во втором методе размеры корректные, а вью размещены правильно — можно подвязываться к размерам корневой вью.

Есть отдельный метод про изменение размеров вью. Это необязательно поворот устройства, хотя он тоже:

```swift
override func viewWillTransition(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator) {
    super.viewWillTransition(to: size, with: coordinator)
}
```

После будут вызваны методы `viewWillLayoutSubviews()` и `viewDidLayoutSubviews()`.

## Кончилась память

Если вы не очистите объекты, из-за которых это происходит, iOS принудительно крашнет приложение. Этот метод - предупреждение, у вас есть шанс освободить немного памяти.

```swift
override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
}
```
